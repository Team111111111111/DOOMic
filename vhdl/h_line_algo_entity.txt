-- Completly not done yet

entity h_line is
	port (	clk		: in	std_logic;
		reset		: in	std_logic;
		v_busy		: in	std_logic;

		x		: in	std_logic_vector (8 downto 0);
		y_top		: in	std_logic_vector (7 downto 0);
		y_bot		: in	std_logic_vector (7 downto 0);

		x2		: in	std_logic_vector (8 downto 0);
		y2_top		: in	std_logic_vector (7 downto 0);
		y2_bot		: in	std_logic_vector (7 downto 0);

		active		: out	std_logic;
		adress_out	: out std_logic_vector(15 downto 0);
		

	--	math_var1_out	: out   std_logic_vector (15 downto 0);
	--	math_var2_out	: out   std_logic_vector (15 downto 0);
	--	math_var1_in	: in	std_logic_vector (15 downto 0);
	--	math_command	: in	std_logic_vector (???????????) #Dunno how 
	);
end entity h_line;
















architecture behavioural of h_line is
	type states is (		reset,
	
					dy_calc1,
					dy_calc2,
					dx_calc,
					y_compare,

					dx_dy_compare, 

					for_loop_x_branch;
					draw_1_x_branch, 
					draw_2_x_branch,
					e_calc_x_branch,
					if_compare_x_branch,
					e_calc1_x_branch,
					y_calc1_x_branch,
					x_increase_x_branch,
 
					out_done,

					for_loop_y_branch;
					draw_1_y_branch, 
					draw_2_y_branch,
					e_calc_y_branch,
					if_compare_y_branch,
					e_calc1_y_branch,
					x_calc1_y_branch,
					y_increase_y_branch);
	
	signal state, new_state: for-loop_states;
	signal x_pos:	unsigned (9-1 downto 0); --8bits
	signal y_pos:	unsigned (8-1 downto 0);
	signal e:	signed (14-1 downto 0); -- 14 bits
	signal e_shift: signed (15-1 downt0 0); --15bits
	signal dy, yL, yR: unsigned (7 downto 0);
	signal dx: unsigned (8 downto 0);


begin
	process (clk)
	begin	
		if (rising_edge (clk)) then
			if (reset = '1') then
				state <= reset;
			else 
				state <= new_state;
			end if;
		end if;
	end process;

	process(state)
	begin
		case state is
			when reset =>
				x_pos <= (others => '0');
				y_pos <= (others => '0');
				e     <= (others => '0');
				active <= '0';
				adress_out <= (others => '0');

				if (v_busy = '1') then
					next_state <= reset;
				else
					next_state <= dx_calc;


			when dx_calc;
				active <= '1';
				adress_out <= (others => '0');

				dx <= x2-x1;

				next_state <= y_compare;


			when y_compare;
				active <= '1';
				adress_out <= (others => '0');

				if (y_top<y2_top) then
					next_state <= dy_calc1;
				else
					next_state <= dy_calc2;


			when dy-calc1 =>
				active <= '1';
				adress_out <= (others => '0');

				dy <= (y2_top-y_top);
				yL <= y_top;
				yR <= y2_top;
				x_pos <= x1;
				y_pos <= y_top;

				next_state => dx_dy_compare;


			when dy-calc2 =>
				active <= '1';
				adress_out <= (others => '0');

				dy <= (y2_bot-y_bot);
				yL <= y_bot;
				yR <= y2_bot;
				x_pos <= x1;
				y_pos <= y_bot;

				next_state => dy_dy_compare;

				
			when dx_dy_compare =>
				active <= '1';
				adress_out <= (others => '0');

				if (dx => dy) then
					next_state <= for_loop_x_branch;
				else	
					next_state <= for_loop_y_branch;


			when for_loop_x_branch =>
				active <= '1';
				adress_out <= (others => '0');

				if (x1<=x_pos<=x2) then

					next_state <= draw_1_x_branch;
				else 
					next_state <= out_done;	


			when out_done =>
				active <= '0';
				adress_out <= (others => '0');

					next_state <= reset;


			when draw_1_x_branch =>
				active <= '1';
				--adress_out <= --MEMORY 320Y+X

				next_state <= draw_2_x_branch;


			when draw_2_x_branch =>
				active <= '1';
				--adress_out <= --MEMORY 320Y+X

				next_state <= e_calc_x_branch;


			when e_calc_x_branch =>
				active <= '1';
				adress_out <= (others => '0');

				e <= e + ("000000" & dy);

				next_state <= if_compare_x_branch;

			
			when if_compare_x_branch =>

				active <= '1';
				adress_out <= (others => '0');

				e_shift <= (e & '0');

				if (e_shift => ("00000" & dx)) then
					next_state <= e_calc1_x_branch;
				else
					next_state <= x_increase_x_branch;


			when e_calc1_x_branch => 
				active <= '1';
				adress_out <= (others => '0');

				e <= e - ("00000" & dx);

				next_state <= y_calc1_x_branch;


			when y_calc1_x_branch => 
				active <= '1';
				adress_out <= (others => '0');

				y_pos <= y_pos + 1;

				next_state <= x_increase_x_branch;


			when x_increase_x_branch =>
				active <= '1';
				adress_out <= (others => '0');
				x_pos <= x_pos + 1;

				next_state <= for_loop_x_branch;


				


----------------------------------------------------------------------------
-----------------------Y ITERATION------------------------------------------


			when for_loop_y_branch =>
				active <= '1';
				adress_out <= (others => '0');

				if (yL<=y_pos<=yR) then
					next_state <= draw_1_y_branch;
				else 
					next_state <= out_done;	


			when out_done =>
				active <= '0';
				adress_out <= (others => '0');

					next_state <= reset;


			when draw_1_y_branch =>
				active <= '1';
				--adress_out <= --MEMORY 320y_pos+x_pos

				next_state <= draw_2_y_branch;


			when draw_2_y_branch =>
				active <= '1';
				--adress_out <= --MEMORY 320y_pos+x_pos

				next_state <= if_compare_y_branch;


			when e_calc_y_branch =>
				active <= '1';
				adress_out <= (others => '0');

				e <= e + ("00000" & dx);

				next_state <= if_compare_y_branch;

			
			when if_compare_y_branch =>
				active <= '1';
				adress_out <= (others => '0');

				e_shift <= (e & '0');

				if (e_shift => ("000000" & dy)) then
					next_state <= e_calc1_y_branch;
				else
					next_state <= y_increase_y_branch;


			when e_calc1_y_branch => 
				active <= '1';
				adress_out <= (others => '0');

				e <= e - ("000000" & dy);

				next_state <= y_calc1_y_branch;


			when y_calc1_y_branch => 
				active <= '1';
				adress_out <= (others => '0');

				y_pos <= y_pos + 1;
				x_pos <= x_pos + 1;

				next_state <= for_loop_y_branch;


			when y_increase_y_branch =>
				active <= '1';
				adress_out <= (others => '0');
				y_pos <= y_pos + 1;

				next_state <= for_loop_y_branch;


		end case;
	end process;

end architecture behavioural;